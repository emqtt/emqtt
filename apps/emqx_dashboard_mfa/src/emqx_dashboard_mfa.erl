%%--------------------------------------------------------------------
%% Copyright (c) 2024-2025 EMQ Technologies Co., Ltd. All Rights Reserved.
%%--------------------------------------------------------------------

-module(emqx_dashboard_mfa).

-feature(maybe_expr, enable).

-include_lib("emqx/include/logger.hrl").
-include_lib("hocon/include/hoconsc.hrl").
-include_lib("emqx_dashboard/include/emqx_dashboard.hrl").

-export([
    config_ref/1,
    api_ref/2
]).

-export([sign_token/2, verify/1, setup_user_mfa/2]).

-export([types/0, modules/0, methods/0]).

-dialyzer({no_match, [setup_user_mfa/2]}).

%%------------------------------------------------------------------------------
%% Callbacks
%%------------------------------------------------------------------------------

-type hocon_ref() :: ?R_REF(Module :: atom(), Name :: atom() | binary()).

-type mfa_context() :: map().
-type mfa_method() :: totp.

-type mfa_setting() :: #{
    method := mfa_method(),
    atom() => term()
}.

-callback config_ref() -> hocon_ref().
-callback api_ref(atom()) -> hocon_ref().

%% Currently, We have only implemented the TOTP method which is stateless,
%% so the state maintenance interface is not necessary now.
%% -callback create(Config :: config()) ->
%%     {ok, State :: state()} | {error, Reason :: term()}.
%% -callback update(Config :: config(), State :: state()) ->
%%     {ok, NewState :: state()} | {error, Reason :: term()}.
%% -callback destroy(State :: state()) -> ok.

-callback setup_user_mfa(Req :: map()) ->
    {ok, Result :: map(), Resp :: map()} | {error, Reason :: term()}.

%% @doc this is called during the first phase of a method to initiate a context for this time login
%% the `mfa_setting` is the setting of current user
-callback initiate(dashboard_username(), mfa_setting()) ->
    {ok, Context :: emqx_dashboard_mfa_token:context()}
    | {error, Reason :: term()}.

%% @doc this is called during the second phase of a method for verification
%% the `mfa_cocntexet` is generated by the previous `initiate`
-callback verify(Req :: map(), mfa_setting(), mfa_context()) ->
    ok
    | {error, Reason :: term()}.

-define(DEFAULT_METHOD, totp).

-export_type([mfa_context/0]).

%%------------------------------------------------------------------------------
%% Callback Interface
%%------------------------------------------------------------------------------
-spec config_ref(Mod :: module()) -> hocon_ref().
config_ref(Mod) ->
    Mod:config_ref().

-spec api_ref(Mod :: module(), Field :: atom()) -> hocon_ref().
api_ref(Mod, Field) ->
    Mod:api_ref(Field).

call_initiate(Mod, Username, Params) ->
    Mod:initiate(Username, Params).

call_verify(Mod, Req, MFA, Context) ->
    Mod:verify(Req, MFA, Context).

call_setup_user_mfa(Mod, Params) ->
    Mod:setup_user_mfa(Params).

%%------------------------------------------------------------------------------
%% API
%%------------------------------------------------------------------------------

sign_token(Username, Password) ->
    case emqx_dashboard_admin:check(Username, Password) of
        {ok, User} ->
            do_sign(User, Password);
        Error ->
            Error
    end.

verify(#{<<"method">> := Method0, <<"token">> := Token} = Req) ->
    maybe
        {ok, Method} ?= emqx_utils:safe_to_existing_atom(Method0),
        true ?= is_enabled(Method),
        {ok, #{username := Username, lazy_token := LazyToken, context := Context}} ?=
            emqx_dashboard_mfa_token:verify(Token),
        [User] ?= emqx_dashboard_admin:lookup_user(Username),
        {ok, MFA} ?= match_user_mfa(User, Method),
        Mod = method_mod(Method),
        ok ?= call_verify(Mod, Req, MFA, Context),
        emqx_dashboard_mfa_token:destroy(Token),
        LazyToken(User)
    else
        {error, invalid_type} ->
            {error, <<"invalid_method">>};
        false ->
            {error, <<"MFA is not enabled">>};
        [] ->
            {error, <<"username_not_found">>};
        Reason ->
            ?SLOG(debug, #{
                msg => "mfa_verification_failed ",
                reason => Reason
            }),
            {error, <<"MFA verification failed">>}
    end;
verify(_Req) ->
    {error, <<"invalid_request">>}.

setup_user_mfa(Username, #{<<"method">> := Method} = Params) ->
    {ok, Method2} = emqx_utils:safe_to_existing_atom(Method),
    Mod = method_mod(Method2),
    case call_setup_user_mfa(Mod, Params) of
        {ok, Settings, Resp} ->
            case do_setup_mfa(Username, Settings) of
                {ok, _} ->
                    {ok, Resp};
                Error ->
                    Error
            end;
        Error ->
            Error
    end.

is_enabled() ->
    emqx_utils_maps:any(
        fun(_Method, #{enable := Enable}) ->
            Enable
        end,
        emqx:get_config([dashboard, mfa], #{})
    ).

is_enabled(Method) ->
    emqx:get_config([dashboard, mfa, Method, enable], false).

types() ->
    maps:keys(methods()).

modules() ->
    maps:values(methods()).

methods() ->
    #{
        totp => emqx_dashboard_mfa_totp
    }.

%%--------------------------------------------------------------------
%% internal
%%--------------------------------------------------------------------
do_sign(#?ADMIN{username = Username, extra = Extra} = User, Password) ->
    case is_enabled() of
        true ->
            case maps:get(mfa, Extra, undefined) of
                undefined ->
                    setup_default_mfa(Username, Password);
                MFA ->
                    sign_token(MFA, Username, Password, #{})
            end;
        _ ->
            emqx_dashboard_admin:do_sign_token(User, Password)
    end.

setup_default_mfa(Username, Password) ->
    Method = ?DEFAULT_METHOD,
    Secret = emqx_dashboard_mfa_totp:generate_secret(),
    Secret2 = emqx_secret:wrap(Secret),
    Settings = #{method => Method, secret => Secret2},
    case do_setup_mfa(Username, Settings) of
        {ok, _} ->
            sign_token(Settings, Username, Password, #{secret => Secret});
        Error ->
            Error
    end.

sign_token(#{method := Method} = MFA, Username, Password, Resp) ->
    Mod = method_mod(Method),
    maybe
        {ok, Context} ?= call_initiate(Mod, Username, MFA),
        {ok, Token} ?= emqx_dashboard_mfa_token:sign(Username, Password, Context),
        {ok, Resp#{method => Method, token => Token}}
    end.

match_user_mfa(User, Method) ->
    maybe
        #?ADMIN{extra = Extra} = User,
        MFA = #{method := Method} ?= maps:get(mfa, Extra, {error, <<"MFA not setup">>}),
        {ok, MFA}
    else
        #{method := UserMethod} ->
            ?SLOG(debug, #{
                msg => "unmatched_method",
                method => UserMethod,
                expected => Method
            }),
            {error, <<"unmatched_method">>};
        Error ->
            Error
    end.

method_mod(Method) when is_atom(Method) ->
    maps:get(Method, methods());
method_mod(Method) when is_binary(Method) ->
    {ok, Method1} = emqx_utils:safe_to_existing_atom(Method),
    method_mod(Method1).

do_setup_mfa(Username, Settings) ->
    emqx_dashboard_admin:update_user_extra(
        Username,
        fun(Extra) ->
            Extra#{mfa => Settings}
        end
    ).
