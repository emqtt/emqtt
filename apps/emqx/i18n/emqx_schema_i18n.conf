emqx_schema {

  force_shutdown_enable {
    desc {
      en: "Enable `force_shutdown` feature."
      zh: "启用 `force_shutdown` 功能"
    }
    label {
      en: "Enable `force_shutdown` feature."
      zh: "启用 `force_shutdown` 功能"
    }
  }

  force_shutdown_max_message_queue_len {
    desc {
      en: "Maximum message queue length."
      zh: "消息队列的最大长度"
    }
    label {
      en: "Maximum message queue length."
      zh: "消息队列的最大长度"
    }
  }

  force_shutdown_max_heap_size {
    desc {
        en: "Total heap size"
        zh: "Heap 的总大小"
    }
    label {
        en: "Total heap size"
        zh: "Heap 的总大小"
    }
  }

  overload_protection_enable {
    desc {
        en: "React on system overload or not"
        zh: "是否对系统过载做出反应"
    }
    label {
        en: "React on system overload or not"
        zh: "是否对系统过载做出反应"
    }
  }

  overload_protection_backoff_delay {
    desc {
        en: "Some unimportant tasks could be delayed "
            "for execution, here set the delays in ms"
        zh: "一些不重要的任务可能会延迟执行，以毫秒为单位设置延迟"
    }
    label {
        en: "Delay Time"
        zh: "延迟时间"
    }
  }

  overload_protection_backoff_gc {
    desc {
        en: "Skip forceful GC if necessary"
        zh: "如有必要，跳过强制GC"
    }
    label {
        en: "Skip GC"
        zh: "跳过GC"
    }
  }

  overload_protection_backoff_hibernation {
    desc {
        en: "Skip process hibernation if necessary"
        zh: "如有必要，跳过进程休眠"
    }
    label {
        en: "Skip hibernation"
        zh: "跳过休眠"
    }
  }

  overload_protection_backoff_new_conn {
    desc {
        en: "Close new incoming connections if necessary"
        zh: "如有必要，关闭新进来的连接"
    }
    label {
        en: "Close new connections"
        zh: "关闭新连接"
    }
  }

  conn_congestion_enable_alarm {
    desc {
        en: "Enable or disable connection congestion alarm."
        zh: "启用或者禁用连接阻塞告警功能"
    }
    label {
        en: "Enable/disable congestion alarm"
        zh: "启用/禁用阻塞告警"
    }
  }

  conn_congestion_min_alarm_sustain_duration {
    desc {
        en: "Minimal time before clearing the alarm.\n\n"
            "The alarm is cleared only when there's no pending data in\n"
            "the queue, and at least `min_alarm_sustain_duration`\n"
            "milliseconds passed since the last time we considered the connection \"congested\".\n\n"
            "This is to avoid clearing and raising the alarm again too often."
        zh: "清除警报前的最短时间。\n\n"
            "只有当队列中没有挂起的数据，并且连接至少被堵塞了 \"min_alarm_sustain_duration\" 毫秒时，\n"
            "报警才会被清除。这是为了避免太频繁地清除和再次发出警报."
    }
    label {
        en: "Sustain duration"
        zh: "告警维持时间"
    }
  }

  force_gc_enable {
    desc {
        en: "Enable forced garbage collection."
        zh: "启用强制垃圾回收"
    }
    label {
        en: "Enable forced garbage collection."
        zh: "启用强制垃圾回收"
    }
  }

  force_gc_count {
    desc {
        en: "GC the process after this many received messages."
        zh: "在进程收到多少消息之后，对此进程执行垃圾回收"
    }
    label {
        en: "Process GC messages num"
        zh: "垃圾回收消息数"
    }
  }

  force_gc_bytes {
    desc {
        en: "GC the process after specified number of bytes have passed through."
        zh: "在进程处理过多少个字节之后，对此进程执行垃圾回收"
    }
    label {
        en: "Process GC bytes"
        zh: "垃圾回收字节数"
    }
  }

  sysmon_vm_process_check_interval {
    desc {
        en: "The time interval for the periodic process limit check."
        zh: "定期进程限制检查的时间间隔。"
    }
    label {
        en: "Process limit check interval"
        zh: "进程限制检查时间"
    }
  }

  sysmon_vm_process_high_watermark {
    desc {
        en: "The threshold, as percentage of processes, for how many\n"
            " processes can simultaneously exist at the local node before the corresponding\n"
            " alarm is raised."
        zh: "在发出相应警报之前，本地节点上可以同时存在多少进程的阈值（以进程百分比表示）。"
    }
    label {
        en: "Process high watermark"
        zh: "进程数高水位线"
    }
  }

  sysmon_vm_process_low_watermark {
    desc {
        en: "The threshold, as percentage of processes, for how many\n"
            " processes can simultaneously exist at the local node before the corresponding\n"
            " alarm is cleared."
        zh: "在清除相应警报之前，本地节点上可以同时存在多少进程的阈值（以进程百分比表示）。"
    }
    label {
        en: "Process low watermark"
        zh: "进程数低水位线"
    }
  }

  sysmon_vm_long_gc {
    desc {
        en: "Enable Long GC monitoring."
        zh: "启用长垃圾回收监控"
    }
    label {
        en: "Enable Long GC monitoring."
        zh: "启用长垃圾回收监控"
    }
  }

  sysmon_vm_long_schedule {
    desc {
        en: "Enable Long Schedule monitoring."
        zh: "启用长调度监控"
    }
    label {
        en: "Enable Long Schedule monitoring."
        zh: "启用长调度监控"
    }
  }

  sysmon_vm_large_heap {
    desc {
        en: "Enable Large Heap monitoring."
        zh: "启用大 heap 监控"
    }
    label {
        en: "Enable Large Heap monitoring."
        zh: "启用大 heap 监控"
    }
  }

  sysmon_vm_busy_dist_port {
    desc {
        en: "Enable Busy Distribution Port monitoring."
        zh: "启用分布式端口过忙监控"
    }
    label {
        en: "Enable Busy Distribution Port monitoring."
        zh: "启用分布式端口过忙监控"
    }
  }

  sysmon_vm_busy_port {
    desc {
        en: "Enable Busy Port monitoring."
        zh: "启用端口过忙监控"
    }
    label {
        en: "Enable Busy Port monitoring."
        zh: "启用端口过忙监控"
    }
  }

  sysmon_os_cpu_check_interval {
    desc {
        en: "The time interval for the periodic CPU check."
        zh: "定期 CPU 检查的时间间隔。"
    }
    label {
        en: "The time interval for the periodic CPU check."
        zh: "定期 CPU 检查的时间间隔"
    }
  }

  sysmon_os_cpu_high_watermark {
    desc {
        en: "The threshold, as percentage of system CPU load,\n"
            " for how much system cpu can be used before the corresponding alarm is raised."
        zh: "在发出相应警报之前可以使用多少系统 CPU 的阈值，以系统CPU负载的百分比表示。"
    }
    label {
        en: "CPU high watermark"
        zh: "CPU 高水位线"
    }
  }

  sysmon_os_cpu_low_watermark {
    desc {
        en: "The threshold, as percentage of system CPU load,\n"
            " for how much system cpu can be used before the corresponding alarm is cleared."
        zh: "在解除相应警报之前可以使用多少系统 CPU 的阈值，以系统CPU负载的百分比表示。"
    }
    label {
        en: "CPU low watermark"
        zh: "CPU 低水位线"
    }
  }

  sysmon_os_mem_check_interval {
    desc {
        en: "The time interval for the periodic memory check."
        zh: "定期内存检查的时间间隔。"
    }
    label {
        en: "Mem check interval"
        zh: "内存检查间隔"
    }
  }

  sysmon_os_sysmem_high_watermark {
    desc {
        en: "The threshold, as percentage of system memory,\n"
            " for how much system memory can be allocated before the corresponding alarm is raised."
        zh: "在发出相应报警之前可以分配多少系统内存的阈值，以系统内存的百分比表示。"
    }
    label {
        en: "SysMem high wartermark"
        zh: "系统内存高水位线"
    }
  }

  sysmon_os_procmem_high_watermark {
    desc {
        en: "The threshold, as percentage of system memory,\n"
        " for how much system memory can be allocated by one Erlang process before\n"
        " the corresponding alarm is raised."
        zh: "在发出相应警报之前，一个Erlang进程可以分配多少系统内存的阈值，以系统内存的百分比表示。"
    }
    label {
        en: "ProcMem high wartermark"
        zh: "进程内存高水位线"
    }
  }

  sysmon_top_num_items {
    desc {
        en: "The number of top processes per monitoring group"
        zh: "每个监视组的顶级进程数"
    }
    label {
        en: "Top num items"
        zh: "顶级进程数"
    }
  }

  sysmon_top_sample_interval {
    desc {
        en: "Specifies how often process top should be collected"
        zh: "指定应收集进程顶部的频率"
    }
    label {
        en: "Top sample interval"
        zh: "取样时间"
    }
  }

  sysmon_top_max_procs {
    desc {
        en: "Stop collecting data when the number of processes\n"
            "in the VM exceeds this value"
        zh: "当VM中的进程数超过此值时，停止收集数据"
    }
    label {
        en: "Max procs"
        zh: "最大进程数"
    }
  }

  sysmon_top_db_hostname {
    desc {
        en: "Hostname of the PostgreSQL database that collects the data points"
        zh: "收集数据点的 PostgreSQL 数据库的主机名"
    }
    label {
        en: "DB Hostname"
        zh: "数据库主机名"
    }
  }

  sysmon_top_db_port {
    desc {
        en: "Port of the PostgreSQL database that collects the data points"
        zh: "收集数据点的 PostgreSQL 数据库的端口"
    }
    label {
        en: "DB Port"
        zh: "数据库端口"
    }
  }

  sysmon_top_db_username {
    desc {
        en: "Username of the PostgreSQL database"
        zh: "PostgreSQL 数据库的用户名"
    }
    label {
        en: "DB Username"
        zh: "数据库用户名"
    }
  }

  sysmon_top_db_password {
    desc {
        en: "EMQX user password in the PostgreSQL database"
        zh: "PostgreSQL 数据库的密码"
    }
    label {
        en: "DB Password"
        zh: "数据库密码"
    }
  }

  sysmon_top_db_name {
    desc {
        en: "PostgreSQL database name"
        zh: "PostgreSQL 数据库的数据库名"
    }
    label {
        en: "DB Name"
        zh: "数据库名"
    }
  }

  alarm_actions {
    desc {
        en: "The actions triggered when the alarm is activated.<br/>\n"
            "Currently, the following actions are supported: <code>log</code> and "
            "<code>publish</code>.\n"
            "<code>log</code> is to write the alarm to log (console or file).\n"
            "<code>publish</code> is to publish the alarm as an MQTT message to "
            "the system topics:\n"
            "<code>$SYS/brokers/emqx@xx.xx.xx.x/alarms/activate</code> and\n"
            "<code>$SYS/brokers/emqx@xx.xx.xx.x/alarms/deactivate</code>"
        zh: "警报激活时触发的动作。<br/>\n"
            "目前，支持以下操作：<code>log</code> 和 "
            "<code>publish</code>.\n"
            "<code>log</code> 将告警写入日志 (控制台或者文件).\n"
            "<code>publish</code> 将告警作为 MQTT 消息发布到系统主题:\n"
            "<code>$SYS/brokers/emqx@xx.xx.xx.x/alarms/activate</code> and\n"
            "<code>$SYS/brokers/emqx@xx.xx.xx.x/alarms/deactivate</code>"
    }
    label: {
        en: "Alarm Actions"
        zh: "告警动作"
    }
  }

  alarm_size_limit {
    desc {
        en: "The maximum total number of deactivated alarms to keep as history.<br>\n"
            "When this limit is exceeded, the oldest deactivated alarms are "
            "deleted to cap the total number.\n"
        zh: "要保留为历史记录的已停用报警的最大总数。当超过此限制时，将删除最旧的停用报警，以限制总数。"
    }
    label: {
        en: "Alarm size limit"
        zh: "告警总数限制"
    }
  }

  alarm_validity_period {
    desc {
        en: "Retention time of deactivated alarms. Alarms are not deleted immediately\n"
            "when deactivated, but after the retention time.\n"
        zh: "停用报警的保留时间。报警在停用时不会立即删除，而是在保留时间之后删除。"
    }
    label: {
        en: "Alarm validity period"
        zh: "告警保留时间"
    }
  }

  flapping_detect_enable {
    desc {
        en: "Enable flapping connection detection feature."
        zh: "启用抖动检测功能"
    }
    label: {
        en: "Enable flapping detection"
        zh: "启用抖动检测"
    }
  }

  flapping_detect_max_count {
    desc {
        en: "The maximum number of disconnects allowed for a MQTT Client in `window_time`"
        zh: "MQTT 客户端在\"窗口\"时间内允许的最大断开次数"
    }
    label: {
        en: "Max count"
        zh: "最大断开次数"
    }
  }

  flapping_detect_window_time {
    desc {
        en: "The time window for flapping detection."
        zh: "抖动检测的时间窗口。"
    }
    label: {
        en: "Window time"
        zh: "时间窗口"
    }
  }

  flapping_detect_ban_time {
    desc {
        en: "How long the flapping clientid will be banned."
        zh: "抖动的客户端将会被禁止登陆多长时间"
    }
    label: {
        en: "Ban time"
        zh: "禁止登陆时长"
    }
  }

  persistent_session_store_enabled {
    desc {
        en: "Use the database to store information about persistent sessions.\n"
            "This makes it possible to migrate a client connection to another\n"
            "cluster node if a node is stopped.\n"
        zh: "使用数据库存储有关持久会话的信息。\n"
            "这使得在节点停止时，可以将客户端连接迁移到另一个群集节点。"
    }
    label: {
        en: "Enable persistent session store"
        zh: "启用持久会话保存"
    }
  }

  persistent_session_store_storage_type {
    desc {
        en: "Store information about persistent sessions on disc or in ram.\n"
            "If ram is chosen, all information about persistent sessions remains\n"
            "as long as at least one node in a cluster is alive to keep the information.\n"
            "If disc is chosen, the information is persisted on disc and will survive\n"
            "cluster restart, at the price of more disc usage and less throughput.\n"
        zh: "将有关持久会话的信息存储在磁盘或内存中。\n"
            "如果选择了ram，有关持久会话的所有信息将保留\n"
            "只要群集中至少有一个节点处于活动状态，就可以保留信息。\n"
            "如果选择了光盘，则信息将保留在光盘上，并且将继续存在\n"
            "群集重新启动，代价是磁盘使用量增加，吞吐量降低。\n"
    }
    label: {
        en: "Storage type"
        zh: "存储类型"
    }
  }

  persistent_session_store_max_retain_undelivered {
    desc {
        en: "The time messages that was not delivered to a persistent session\n"
            "is stored before being garbage collected if the node the previous\n"
            "session was handled on restarts of is stopped.\n"
        zh: "如果重新启动时处理上一个会话的节点已停止，则未传递到持久会话的消息在垃圾收集之前会被存储。"
    }
    label: {
        en: "Max retain undelivered"
        zh: "未投递的消息保留条数"
    }
  }

  persistent_session_store_message_gc_interval {
    desc {
        en: "The starting interval for garbage collection of undelivered messages to\n"
            "a persistent session. This affects how often the \"max_retain_undelivered\"\n"
            "is checked for removal.\n"
        zh: "将未送达的消息垃圾收集到持久会话的开始间隔。\n"
            "这会影响检查 \"max_retain_undelivered\"（最大保留未送达）的删除频率。"
    }
    label: {
        en: "Message GC interval"
        zh: "消息清理间隔"
    }
  }

  persistent_session_store_session_message_gc_interval {
    desc {
        en: "The starting interval for garbage collection of transient data for\n"
            "persistent session messages. This does not affect the lifetime length\n"
            "of persistent session messages.\n"
        zh: "持久会话消息的临时数据垃圾收集的开始间隔。\n"
            "这不会影响持久会话消息的生命周期长度。\n"
    }
    label: {
        en: "Session message GC interval"
        zh: "会话消息清理间隔"
    }
  }

  stats_enable {
    desc {
        en: "Enable/disable statistic data collection."
        zh: "启用/禁用统计数据收集功能"
    }
    label: {
        en: "Enable/disable statistic data collection."
        zh: "启用/禁用统计数据收集功能"
    }
  }

    zones {
        desc {
            en: """A zone is a set of configs grouped by the zone <code>name</code>.
For flexible configuration mapping, the <code>name</code> can be set to a listener's <code>zone</code> config.
NOTE: A built-in zone named <code>default</code> is auto created and can not be deleted.
"""
            zh: """<code>zone</code> 是按<code>name</code> 分组的一组配置。
对于灵活的配置映射，可以将 <code>name</code> 设置为侦听器的 <code>zone</code> 配置。
注：名为 <code>default</code> 的内置区域是自动创建的，无法删除。"""
        }
    }

    mqtt {
        desc {
            en: """Global MQTT configuration.
The configs here work as default values which can be overridden in <code>zone</code> configs
"""
            zh: """全局的 MQTT 配置项。
mqtt 下所有的配置作为全局的默认值存在，它可以被 <code>zone</code> 中的配置覆盖。"""
        }
    }

    mqtt_idle_timeout {
        desc {
            en: """Close TCP connections from the clients that have not sent MQTT CONNECT message within this interval."""
            zh: """关闭在此时间间隔内未发送 MQTT CONNECT 消息的客户端的 TCP 连接。"""
        }
    }

    mqtt_max_packet_size {
        desc {
            en: """Maximum MQTT packet size allowed."""
            zh: """允许的最大 MQTT 报文大小。"""
        }
    }

    mqtt_max_clientid_len {
        desc {
            en: """"Maximum allowed length of MQTT clientId."""
            zh: """允许的最大 MQTT Client ID 长度"""
        }
    }

    mqtt_max_topic_levels {
        desc {
            en: """Maximum topic levels allowed."""
            zh: """允许的 Topic 最大层级数"""
        }
    }

    mqtt_max_qos_allowed {
        desc {
            en: """Maximum QoS allowed."""
            zh: """允许的最大 QoS 等级。"""
        }
    }

    mqtt_max_topic_alias {
        desc {
            en: """Maximum Topic Alias, 0 means no topic alias supported."""
            zh: """允许的最大主题别名数，0 表示不支持主题别名。"""
        }
    }

    mqtt_retain_available {
        desc {
            en: """Support MQTT retained messages."""
            zh: """是否支持 retained 消息。"""
        }
    }

    mqtt_wildcard_subscription {
        desc {
            en: """Support MQTT Wildcard Subscriptions."""
            zh: """是否支持主题的通配符订阅。"""
        }
    }

    mqtt_shared_subscription {
        desc {
            en: """Support MQTT Shared Subscriptions."""
            zh: """是否支持 MQTT 共享订阅"""
        }
    }

    mqtt_ignore_loop_deliver {
        desc {
            en: """Ignore loop delivery of messages for MQTT v3.1.1/v3.1.0."""
            zh: """是否为 MQTT v3.1.1/v3.1.0 客户端忽略接收自己发布出消息"""
        }
    }

    mqtt_strict_mode {
        desc {
            en: """Parse MQTT messages in strict mode.
When set to true, invalid utf8 strings in for example client ID, topic name, etc. will cause the client to be disconnected"""
            zh: """是否以严格模式解析 MQTT 消息。
当设置为 true 时，例如客户端 ID、主题名称等中的无效 utf8 字符串将导致客户端断开连接。"""
        }
    }

    mqtt_response_information {
        desc {
            en: """Specify the response information returned to the client. This feature is disabled if is set to \"\"."""
            zh: """指定返回给客户端的响应信息。如果设置为 \"\"，则禁用此功能。"""
        }
    }

    mqtt_server_keepalive {
        desc {
            en: """'Server Keep Alive' of MQTT 5.0.
If the server returns a 'Server Keep Alive' in the CONNACK packet, the client MUST use that value instead of the value it sent as the 'Keep Alive'."""
            zh: """MQTT 5.0 的 'Server Keep Alive' 属性。
如果服务器在 CONNACK 数据包中返回'Server Keep Alive'，则客户端必须使用该值作为实际的 'Keep Alive' 值。"""
        }
    }

    mqtt_keepalive_backoff {
        desc {
            en: """The backoff for MQTT keepalive timeout. The broker will close the connection after idling for 'Keepalive * backoff * 2'."""
            zh: """Broker 判定客户端 Keep Alive 超时的退避乘数。EMQX 将在'Keepalive * backoff * 2' 空闲后关闭连接。"""
        }
    }

    mqtt_max_subscriptions {
        desc {
            en: """Maximum number of subscriptions allowed."""
            zh: """允许的每个客户端最大订阅数"""
        }
    }

    mqtt_upgrade_qos {
        desc {
            en: """Force upgrade of QoS level according to subscription."""
            zh: """投递消息时，是否根据订阅主题时的 QoS 等级来强制提升派发的消息的 QoS 等级。"""
        }
    }

    mqtt_max_inflight {
        desc {
            en: """Maximum size of the Inflight Window storing QoS1/2 messages delivered but un-acked."""
            zh: """飞行窗口的最大值。"""
        }
    }

    mqtt_retry_interval {
        desc {
            en: """Retry interval for QoS1/2 message delivering."""
            zh: """QoS1/2 消息的重新投递间隔。"""
        }
    }

    mqtt_max_awaiting_rel {
        desc {
            en: """Maximum QoS2 packets (Client -> Broker) awaiting PUBREL."""
            zh: """PUBREL (Client -> Broker) 最大等待队列长度。"""
        }
    }

    mqtt_await_rel_timeout {
        desc {
            en: """The QoS2 messages (Client -> Broker) will be dropped if awaiting PUBREL timeout."""
            zh: """PUBREL (Client -> Broker) 最大等待时间，超时则会被丢弃。"""
        }
    }

    mqtt_session_expiry_interval {
        desc {
            en: """Default session expiry interval for MQTT V3.1.1 connections."""
            zh: """Session 默认超时时间。"""
        }
    }

    mqtt_max_mqueue_len {
        desc {
            en: """Maximum queue length. Enqueued messages when persistent client disconnected, or inflight window is full."""
            zh: """消息队列最大长度。持久客户端断开连接或飞行窗口已满时排队的消息长度。"""
        }
    }

    mqtt_mqueue_priorities {
        desc {
            en: """Topic priorities. Priority number [1-255]
There's no priority table by default, hence all messages are treated equal.

**NOTE**: Comma and equal signs are not allowed for priority topic names.
**NOTE**: Messages for topics not in the priority table are treated as either highest or lowest priority depending on the configured value for <code>mqtt.mqueue_default_priority</code>.

**Examples**:
To configure <code>\"topic/1\" > \"topic/2\"</code>:
<code>mqueue_priorities: {\"topic/1\": 10, \"topic/2\": 8}</code>
"""
            zh: """主题优先级。取值范围 [1-255]
默认优先级表为空，即所有的主题优先级相同。

注：优先主题名称中不支持使用逗号和等号。
注：不在此列表中的主题，被视为最高/最低优先级，这取决于<code>mqtt.mqueue_default_priority</code> 的配置

示例：
配置 <code>\"topic/1\" > \"topic/2\"</code>:
<code>mqueue_priorities: {\"topic/1\": 10, \"topic/2\": 8}</code>
"""
        }
    }

    mqtt_mqueue_default_priority {
        desc {
            en: """Default to the highest priority for topics not matching priority table."""
            zh: """主题默认的优先级，不在 <code>mqtt.mqueue_priorities</code> 中的主题将会使用该优先级。"""
        }
    }

    mqtt_mqueue_store_qos0 {
        desc {
            en: """Support enqueue QoS0 messages."""
            zh: """消息队列是否存储 QoS0 消息。"""
        }
    }

    mqtt_use_username_as_clientid {
        desc {
            en: """Replace client ID with the username."""
            zh: """是否使用 Client ID 替换 Username。"""
        }
    }

    mqtt_peer_cert_as_username {
        desc {
            en: """Use the CN, DN or CRT field from the client certificate as a username.
Only works for the TLS connection."""
            zh: """使用客户端证书中的 CN, DN 字段或整个证书来作为客户端用户名。"""
        }
    }

    mqtt_peer_cert_as_clientid {
        desc {
            en: """Use the CN, DN or CRT field from the client certificate as a clientid.
Only works for the TLS connection."""
            zh: """使用客户端证书中的 CN, DN 字段或整个证书来作为客户端 ID。"""
        }
    }

    broker {
        desc {
            en: """"Message broker options."""
            zh: """Broker 相关配置项。"""
        }
    }

    broker_enable_session_registry {
        desc {
            en: """Enable session registry"""
            zh: """是否启用 Session Registry"""
        }
    }

    broker_session_locking_strategy {
        desc {
            en: """Session locking strategy in a cluster.
  - `local`: only lock the session on the current node
  - `one`: select only one remote node to lock the session
  - `quorum`: select some nodes to lock the session
  - `all`: lock the session on all the nodes in the cluster
"""

            zh: """Session 在集群中的锁策略。
  - `loca`: 仅锁本节点的 Session
  - `one`: 任选一个其它节点加锁
  - `quorum`: 选择集群中半数以上的节点加锁
  - `all`: 选择所有节点加锁
"""
        }
    }

    broker_shared_subscription_strategy {
        desc {
            en: """Dispatch strategy for shared subscription.
  - `random`: dispatch the message to a random selected subscriber
  - `round_robin`: select the subscribers in a round-robin manner
  - `sticky`: always use the last selected subscriber to dispatch, until the subscriber disconnects.
  - `hash`: select the subscribers by the hash of `clientIds`
"""

            zh: """共享订阅消息派发策略。
  - `random`: 随机挑选一个共享订阅者派发
  - `round_robin`: 使用 round-robin 策略派发
  - `sticky`: 总是使用上次选中的订阅者派发，直到它断开连接
  - `hash`: 使用发送者的 Client ID 进行 Hash 来选择订阅者
"""
        }
    }

    broker_shared_dispatch_ack_enabled {
        desc {
            en: """Enable/disable shared dispatch acknowledgement for QoS1 and QoS2 messages.
This should allow messages to be dispatched to a different subscriber in the group in case the picked (based on `shared_subscription_strategy`) subscriber is offline.
"""

            zh: """启用/禁用 QoS1 和 QoS2 消息的共享派发确认。
开启后，允许将消息从未及时回复 ACK 的订阅者 （例如，客户端离线）重新派发给另外一个订阅者。
"""
        }
    }

    broker_route_batch_clean {
        desc {
            en: """Enable batch clean for deleted routes."""
            zh: """是否开启批量清除路由。"""
        }
    }

    broker_perf_route_lock_type {
        desc {
            en: """Performance tuning for subscribing/unsubscribing a wildcard topic.
Change this parameter only when there are many wildcard topics.

NOTE: when changing from/to `global` lock, it requires all nodes in the cluster to be stopped before the change.
  - `key`: mnesia transactional updates with per-key locks. Recommended for a single-node setup.
  - `tab`: mnesia transactional updates with table lock. Recommended for a cluster setup.
  - `global`: updates are protected with a global lock. Recommended for large clusters.
"""
            zh: """通配主题订阅/取消订阅性能调优。
建议仅当通配符主题较多时才更改此参数。

注：当从/更改为 `global` 锁时，它要求集群中的所有节点在更改之前停止。
  - `key`: 为 Mnesia 事务涉及到的每个 key 上锁，建议单节点时使用。
  - `tab`: 为 Mnesia 事务涉及到的表上锁，建议在集群中使用。
  - `global`: 所以更新操作都被全局的锁保护，仅建议在超大规模集群中使用。
"""
        }
    }

    broker_perf_trie_compaction {
        desc {
            en: """Enable trie path compaction.
Enabling it significantly improves wildcard topic subscribe rate, if wildcard topics have unique prefixes like: 'sensor/{{id}}/+/', where ID is unique per subscriber.
Topic match performance (when publishing) may degrade if messages are mostly published to topics with large number of levels.

NOTE: This is a cluster-wide configuration. It requires all nodes to be stopped before changing it.
"""
            zh: """是否开启主题表压缩存储。
启用它会显着提高通配符主题订阅率，如果通配符主题具有唯一前缀，例如：'sensor/{{id}}/+/'，其中每个订阅者的 ID 是唯一的。
如果消息主要发布到具有大量级别的主题，则主题匹配性能（发布时）可能会降低。

注意：这是一个集群范围的配置。 它要求在更改之前停止所有节点。
"""
        }
    }

    sys_topics {
        desc {
            en: """System topics configuration."""
            zh: """系统主题配置。"""
        }
    }

    sys_msg_interval {
        desc {
            en: """Time interval of publishing `$SYS` messages."""
            zh: """发送 `$SYS` 主题的间隔时间。"""
        }
    }

    sys_heartbeat_interval {
        desc {
            en: """Time interval for publishing following heartbeat messages:
  - `$SYS/brokers/<node>/uptime`
  - `$SYS/brokers/<node>/datetime`
"""
            zh: """发送心跳系统消息的间隔时间，它包括：
  - `$SYS/brokers/<node>/uptime`
  - `$SYS/brokers/<node>/datetime`
"""
        }
    }

    sys_event_messages {
        desc {
            en: """Client events messages"""
            zh: """客户端事件消息"""
        }
    }

    sys_event_client_connected {
        desc {
            en: """Enable to publish client connected event messages"""
            zh: """是否开启客户端已连接事件消息。"""
        }
    }

    sys_event_client_disconnected {
        desc {
            en: """Enable to publish client disconnected event messages."""
            zh: """是否开启客户端已断开连接事件消息。"""
        }
    }

    sys_event_client_subscribed {
        desc {
            en: """Enable to publish event message that client subscribed a topic successfully."""
            zh: """是否开启客户端已成功订阅主题事件消息。"""
        }
    }

    sys_event_client_unsubscribed {
        desc {
            en: """Enable to publish event message that client unsubscribed a topic successfully."""
            zh: """是否开启客户端已成功取消订阅主题事件消息。"""
        }
    }

    f_listeners_v_tcp {
        desc {
            en: """TCP listeners"""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_listeners_v_ssl {
        desc {
            en: """SSL listeners"""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_listeners_v_ws {
        desc {
            en: """HTTP websocket listeners"""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_listeners_v_wss {
        desc {
            en: """HTTPS websocket listeners"""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_listeners_v_quic {
        desc {
            en: """QUIC listeners"""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_trace_v_payload_encode {
        desc {
            en: """Determine the format of the payload format in the trace file.<br>
    `text`: Text-based protocol or plain text protocol.
    It is recommended when payload is JSON encoded.<br>
    `hex`: Binary hexadecimal encode. It is recommended when payload is a custom binary protocol.<br>
    `hidden`: payload is obfuscated as `******`
    """
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_authorization_v_no_match {
        desc {
            en: """Default access control action if the user or client matches no ACL rules,
    or if no such user or client is found by the configurable authorization
    sources such as built_in_database, an HTTP API, or a query against PostgreSQL.
    Find more details in 'authorization.sources' config."""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_authorization_v_deny_action {
        desc {
            en: """The action when the authorization check rejects an operation."""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_authorization_v_cache {
        desc {
            en: """authorization.cache"""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_cache_v_enable {
        desc {
            en: """Enable or disable the authorization cache."""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_cache_v_max_size {
        desc {
            en: """Maximum number of cached items."""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_cache_v_ttl {
        desc {
            en: """Time to live for the cached data."""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_mqtt_tcp_listener_v_tcp {
        desc {
            en: """Settings for the MQTT over TCP listener."""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_mqtt_tcp_listener_v_bind {
        desc {
            en: """IP address and port for the listening socket."""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_mqtt_tcp_listener_v_acceptors {
        desc {
            en: """The size of the listener's receiving pool."""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_mqtt_tcp_listener_v_max_connections {
        desc {
            en: """The maximum number of concurrent connections allowed by the listener."""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_mqtt_tcp_listener_v_mountpoint {
        desc {
            en: """When publishing or subscribing, prefix all topics with a mountpoint string.
    The prefixed string will be removed from the topic name when the message
    is delivered to the subscriber. The mountpoint is a way that users can use
    to implement isolation of message routing between different listeners.
    For example if a client A subscribes to `t` with `listeners.tcp.<name>.mountpoint`
    set to `some_tenant`, then the client actually subscribes to the topic
    `some_tenant/t`. Similarly, if another client B (connected to the same listener
    as the client A) sends a message to topic `t`, the message is routed
    to all the clients subscribed `some_tenant/t`, so client A will receive the
    message, with topic name `t`.<br/>
    Set to `""` to disable the feature.<br/>

    Variables in mountpoint string:
    - <code>${clientid}</code>: clientid
    - <code>${username}</code>: username"""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_mqtt_tcp_listener_v_zone {
        desc {
            en: """The configuration zone to which the listener belongs."""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_mqtt_tcp_listener_v_limiter {
        desc {
            en: """Type of the rate limit."""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_mqtt_tcp_listener_v_access_rules {
        desc {
            en: """The access control rules for this listener.<br/>See: https://github.com/emqtt/esockd#allowdeny"""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_mqtt_tcp_listener_v_proxy_protocol {
        desc {
            en: """Enable the Proxy Protocol V1/2 if the EMQX cluster is deployed
    behind HAProxy or Nginx.<br/>See: https://www.haproxy.com/blog/haproxy/proxy-protocol/"""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_mqtt_tcp_listener_v_proxy_protocol_timeout {
        desc {
            en: """Timeout for proxy protocol. EMQX will close the TCP connection if proxy protocol packet is not received within the timeout."""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_mqtt_tcp_listener_v_authentication {
        desc {
            en: """Per-listener authentication override
    Authentication can be one single authenticator instance or a chain of authenticators as an array.
    When authenticating a login (username, client ID, etc.) the authenticators are checked in the configured order.<br>
    """
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_mqtt_ws_listener_v_tcp {
        desc {
            en: """Settings for the MQTT over WebSocket listener."""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_mqtt_ws_listener_v_websocket {
        desc {
            en: """Settings for the MQTT over WebSocket listener."""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_mqtt_ws_listener_v_bind {
        desc {
            en: """IP address and port for the listening socket."""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_mqtt_ws_listener_v_acceptors {
        desc {
            en: """The size of the listener's receiving pool."""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_mqtt_ws_listener_v_max_connections {
        desc {
            en: """The maximum number of concurrent connections allowed by the listener."""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_mqtt_ws_listener_v_mountpoint {
        desc {
            en: """When publishing or subscribing, prefix all topics with a mountpoint string.
    The prefixed string will be removed from the topic name when the message
    is delivered to the subscriber. The mountpoint is a way that users can use
    to implement isolation of message routing between different listeners.
    For example if a client A subscribes to `t` with `listeners.tcp.<name>.mountpoint`
    set to `some_tenant`, then the client actually subscribes to the topic
    `some_tenant/t`. Similarly, if another client B (connected to the same listener
    as the client A) sends a message to topic `t`, the message is routed
    to all the clients subscribed `some_tenant/t`, so client A will receive the
    message, with topic name `t`.<br/>
    Set to `""` to disable the feature.<br/>

    Variables in mountpoint string:
    - <code>${clientid}</code>: clientid
    - <code>${username}</code>: username"""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_mqtt_ws_listener_v_zone {
        desc {
            en: """The configuration zone to which the listener belongs."""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_mqtt_ws_listener_v_limiter {
        desc {
            en: """Type of the rate limit."""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_mqtt_ws_listener_v_access_rules {
        desc {
            en: """The access control rules for this listener.<br/>See: https://github.com/emqtt/esockd#allowdeny"""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_mqtt_ws_listener_v_proxy_protocol {
        desc {
            en: """Enable the Proxy Protocol V1/2 if the EMQX cluster is deployed
    behind HAProxy or Nginx.<br/>See: https://www.haproxy.com/blog/haproxy/proxy-protocol/"""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_mqtt_ws_listener_v_proxy_protocol_timeout {
        desc {
            en: """Timeout for proxy protocol. EMQX will close the TCP connection if proxy protocol packet is not received within the timeout."""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_mqtt_ws_listener_v_authentication {
        desc {
            en: """Per-listener authentication override
    Authentication can be one single authenticator instance or a chain of authenticators as an array.
    When authenticating a login (username, client ID, etc.) the authenticators are checked in the configured order.<br>
    """
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_mqtt_wss_listener_v_tcp {
        desc {
            en: """Settings for the MQTT over WebSocket/SSL listener."""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_mqtt_wss_listener_v_ssl {
        desc {
            en: """Settings for the MQTT over WebSocket/SSL listener."""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_mqtt_wss_listener_v_websocket {
        desc {
            en: """Settings for the MQTT over WebSocket/SSL listener."""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_mqtt_wss_listener_v_bind {
        desc {
            en: """IP address and port for the listening socket."""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_mqtt_wss_listener_v_acceptors {
        desc {
            en: """The size of the listener's receiving pool."""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_mqtt_wss_listener_v_max_connections {
        desc {
            en: """The maximum number of concurrent connections allowed by the listener."""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_mqtt_wss_listener_v_mountpoint {
        desc {
            en: """When publishing or subscribing, prefix all topics with a mountpoint string.
    The prefixed string will be removed from the topic name when the message
    is delivered to the subscriber. The mountpoint is a way that users can use
    to implement isolation of message routing between different listeners.
    For example if a client A subscribes to `t` with `listeners.tcp.<name>.mountpoint`
    set to `some_tenant`, then the client actually subscribes to the topic
    `some_tenant/t`. Similarly, if another client B (connected to the same listener
    as the client A) sends a message to topic `t`, the message is routed
    to all the clients subscribed `some_tenant/t`, so client A will receive the
    message, with topic name `t`.<br/>
    Set to `""` to disable the feature.<br/>

    Variables in mountpoint string:
    - <code>${clientid}</code>: clientid
    - <code>${username}</code>: username"""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_mqtt_wss_listener_v_zone {
        desc {
            en: """The configuration zone to which the listener belongs."""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_mqtt_wss_listener_v_limiter {
        desc {
            en: """Type of the rate limit."""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_mqtt_wss_listener_v_access_rules {
        desc {
            en: """The access control rules for this listener.<br/>See: https://github.com/emqtt/esockd#allowdeny"""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_mqtt_wss_listener_v_proxy_protocol {
        desc {
            en: """Enable the Proxy Protocol V1/2 if the EMQX cluster is deployed
    behind HAProxy or Nginx.<br/>See: https://www.haproxy.com/blog/haproxy/proxy-protocol/"""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_mqtt_wss_listener_v_proxy_protocol_timeout {
        desc {
            en: """Timeout for proxy protocol. EMQX will close the TCP connection if proxy protocol packet is not received within the timeout."""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_mqtt_wss_listener_v_authentication {
        desc {
            en: """Per-listener authentication override
    Authentication can be one single authenticator instance or a chain of authenticators as an array.
    When authenticating a login (username, client ID, etc.) the authenticators are checked in the configured order.<br>
    """
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_mqtt_ssl_listener_v_tcp {
        desc {
            en: """Settings for the MQTT over SSL listener."""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_mqtt_ssl_listener_v_ssl {
        desc {
            en: """Settings for the MQTT over SSL listener."""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_mqtt_ssl_listener_v_bind {
        desc {
            en: """IP address and port for the listening socket."""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_mqtt_ssl_listener_v_acceptors {
        desc {
            en: """The size of the listener's receiving pool."""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_mqtt_ssl_listener_v_max_connections {
        desc {
            en: """The maximum number of concurrent connections allowed by the listener."""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_mqtt_ssl_listener_v_mountpoint {
        desc {
            en: """When publishing or subscribing, prefix all topics with a mountpoint string.
    The prefixed string will be removed from the topic name when the message
    is delivered to the subscriber. The mountpoint is a way that users can use
    to implement isolation of message routing between different listeners.
    For example if a client A subscribes to `t` with `listeners.tcp.<name>.mountpoint`
    set to `some_tenant`, then the client actually subscribes to the topic
    `some_tenant/t`. Similarly, if another client B (connected to the same listener
    as the client A) sends a message to topic `t`, the message is routed
    to all the clients subscribed `some_tenant/t`, so client A will receive the
    message, with topic name `t`.<br/>
    Set to `""` to disable the feature.<br/>

    Variables in mountpoint string:
    - <code>${clientid}</code>: clientid
    - <code>${username}</code>: username"""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_mqtt_ssl_listener_v_zone {
        desc {
            en: """The configuration zone to which the listener belongs."""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_mqtt_ssl_listener_v_limiter {
        desc {
            en: """Type of the rate limit."""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_mqtt_ssl_listener_v_access_rules {
        desc {
            en: """The access control rules for this listener.<br/>See: https://github.com/emqtt/esockd#allowdeny"""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_mqtt_ssl_listener_v_proxy_protocol {
        desc {
            en: """Enable the Proxy Protocol V1/2 if the EMQX cluster is deployed
    behind HAProxy or Nginx.<br/>See: https://www.haproxy.com/blog/haproxy/proxy-protocol/"""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_mqtt_ssl_listener_v_proxy_protocol_timeout {
        desc {
            en: """Timeout for proxy protocol. EMQX will close the TCP connection if proxy protocol packet is not received within the timeout."""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_mqtt_ssl_listener_v_authentication {
        desc {
            en: """Per-listener authentication override
    Authentication can be one single authenticator instance or a chain of authenticators as an array.
    When authenticating a login (username, client ID, etc.) the authenticators are checked in the configured order.<br>
    """
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_mqtt_quic_listener_v_enabled {
        desc {
            en: """Enable QUIC listener."""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_mqtt_quic_listener_v_certfile {
        desc {
            en: """Path to the certificate file."""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_mqtt_quic_listener_v_keyfile {
        desc {
            en: """Path to the secret key file."""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_mqtt_quic_listener_v_ciphers {
        desc {
            en: """This config holds TLS cipher suite names separated by comma,
    or as an array of strings. e.g.
    <code>"TLS_AES_256_GCM_SHA384,TLS_AES_128_GCM_SHA256"</code> or
    <code>["TLS_AES_256_GCM_SHA384","TLS_AES_128_GCM_SHA256"]</code>.
    <br>
    Ciphers (and their ordering) define the way in which the
    client and server encrypts information over the network connection.
    Selecting a good cipher suite is critical for the
    application's data security, confidentiality and performance.

    The names should be in OpenSSL string format (not RFC format).
    All default values and examples provided by EMQX config
    documentation are all in OpenSSL format.<br>

    NOTE: Certain cipher suites are only compatible with
    specific TLS <code>versions</code> ('tlsv1.1', 'tlsv1.2' or 'tlsv1.3')
    incompatible cipher suites will be silently dropped.
    For instance, if only 'tlsv1.3' is given in the <code>versions</code>,
    configuring cipher suites for other versions will have no effect.
    <br>

    NOTE: PSK ciphers are suppressed by 'tlsv1.3' version config<br>
    If PSK cipher suites are intended, 'tlsv1.3' should be disabled from <code>versions</code>.<br>
    PSK cipher suites: <code>"RSA-PSK-AES256-GCM-SHA384,RSA-PSK-AES256-CBC-SHA384,
    RSA-PSK-AES128-GCM-SHA256,RSA-PSK-AES128-CBC-SHA256,
    RSA-PSK-AES256-CBC-SHA,RSA-PSK-AES128-CBC-SHA,
    RSA-PSK-DES-CBC3-SHA,RSA-PSK-RC4-SHA"</code><br>
    NOTE: QUIC listener supports only 'tlsv1.3' ciphers<br>"""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_mqtt_quic_listener_v_idle_timeout {
        desc {
            en: """Close transport-layer connections from the clients that have not sent MQTT CONNECT
    message within this interval."""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_mqtt_quic_listener_v_bind {
        desc {
            en: """IP address and port for the listening socket."""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_mqtt_quic_listener_v_acceptors {
        desc {
            en: """The size of the listener's receiving pool."""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_mqtt_quic_listener_v_max_connections {
        desc {
            en: """The maximum number of concurrent connections allowed by the listener."""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_mqtt_quic_listener_v_mountpoint {
        desc {
            en: """When publishing or subscribing, prefix all topics with a mountpoint string.
    The prefixed string will be removed from the topic name when the message
    is delivered to the subscriber. The mountpoint is a way that users can use
    to implement isolation of message routing between different listeners.
    For example if a client A subscribes to `t` with `listeners.tcp.<name>.mountpoint`
    set to `some_tenant`, then the client actually subscribes to the topic
    `some_tenant/t`. Similarly, if another client B (connected to the same listener
    as the client A) sends a message to topic `t`, the message is routed
    to all the clients subscribed `some_tenant/t`, so client A will receive the
    message, with topic name `t`.<br/>
    Set to `""` to disable the feature.<br/>

    Variables in mountpoint string:
    - <code>${clientid}</code>: clientid
    - <code>${username}</code>: username"""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_mqtt_quic_listener_v_zone {
        desc {
            en: """The configuration zone to which the listener belongs."""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_mqtt_quic_listener_v_limiter {
        desc {
            en: """Type of the rate limit."""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_ws_opts_v_mqtt_path {
        desc {
            en: """WebSocket's MQTT protocol path. So the address of
    EMQX Broker's WebSocket is: <code>ws://{ip}:{port}/mqtt</code>"""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_ws_opts_v_mqtt_piggyback {
        desc {
            en: """Whether a WebSocket message is allowed to contain multiple MQTT packets."""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_ws_opts_v_compress {
        desc {
            en: """If <code>true</code>, compress WebSocket messages using <code>zlib</code>.<br/>
    The configuration items under <code>deflate_opts</code> belong to the compression-related parameter configuration."""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_ws_opts_v_idle_timeout {
        desc {
            en: """Close transport-layer connections from the clients that have not sent MQTT CONNECT
    message within this interval."""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_ws_opts_v_max_frame_size {
        desc {
            en: """The maximum length of a single MQTT packet."""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_ws_opts_v_fail_if_no_subprotocol {
        desc {
            en: """If <code>true</code>, the server will return an error when
    the client does not carry the <code>Sec-WebSocket-Protocol</code> field.
    <br/>Note: WeChat applet needs to disable this verification."""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_ws_opts_v_supported_subprotocols {
        desc {
            en: """Comma-separated list of supported subprotocols."""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_ws_opts_v_check_origin_enable {
        desc {
            en: """If <code>true</code>, <code>origin</code> HTTP header will be
    validated against the list of allowed origins configured in <code>check_origins</code>
    parameter."""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_ws_opts_v_allow_origin_absence {
        desc {
            en: """If <code>false</code> and <code>check_origin_enable</code> is
    <code>true</code>, the server will reject requests that don't have <code>origin</code>
    HTTP header."""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_ws_opts_v_check_origins {
        desc {
            en: """List of allowed origins.<br/>See <code>check_origin_enable</code>."""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_ws_opts_v_proxy_address_header {
        desc {
            en: """HTTP header used to pass information about the client IP address.
    Relevant when the EMQX cluster is deployed behind a load-balancer."""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_ws_opts_v_proxy_port_header {
        desc {
            en: """HTTP header used to pass information about the client port.
    Relevant when the EMQX cluster is deployed behind a load-balancer."""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_ws_opts_v_deflate_opts {
        desc {
            en: """WebSocket listener options."""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_tcp_opts_v_active_n {
        desc {
            en: """Specify the {active, N} option for this Socket.<br/>
    See: https://erlang.org/doc/man/inet.html#setopts-2"""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_tcp_opts_v_backlog {
        desc {
            en: """TCP backlog defines the maximum length that the queue of
    pending connections can grow to."""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_tcp_opts_v_send_timeout {
        desc {
            en: """The TCP send timeout for the connections."""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_tcp_opts_v_send_timeout_close {
        desc {
            en: """Close the connection if send timeout."""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_tcp_opts_v_recbuf {
        desc {
            en: """The TCP receive buffer (OS kernel) for the connections."""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_tcp_opts_v_sndbuf {
        desc {
            en: """The TCP send buffer (OS kernel) for the connections."""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_tcp_opts_v_buffer {
        desc {
            en: """The size of the user-space buffer used by the driver."""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_tcp_opts_v_high_watermark {
        desc {
            en: """The socket is set to a busy state when the amount of data queued internally
    by the VM socket implementation reaches this limit."""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_tcp_opts_v_nodelay {
        desc {
            en: """The TCP_NODELAY flag for the connections."""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_tcp_opts_v_reuseaddr {
        desc {
            en: """The SO_REUSEADDR flag for the connections."""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_listener_ssl_opts_v_enable {
        desc {
            en: """Enable TLS."""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_listener_ssl_opts_v_cacertfile {
        desc {
            en: """Trusted PEM format CA certificates bundle file.<br>
    The certificates in this file are used to verify the TLS peer's certificates.
    Append new certificates to the file if new CAs are to be trusted.
    There is no need to restart EMQX to have the updated file loaded, because
    the system regularly checks if file has been updated (and reload).<br>
    NOTE: invalidating (deleting) a certificate from the file will not affect
    already established connections.
    """
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_listener_ssl_opts_v_certfile {
        desc {
            en: """PEM format certificates chain file.<br>
    The certificates in this file should be in reversed order of the certificate
    issue chain. That is, the host's certificate should be placed in the beginning
    of the file, followed by the immediate issuer certificate and so on.
    Although the root CA certificate is optional, it should be placed at the end of
    the file if it is to be added."""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_listener_ssl_opts_v_keyfile {
        desc {
            en: """PEM format private key file."""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_listener_ssl_opts_v_verify {
        desc {
            en: """Enable or disable peer verification."""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_listener_ssl_opts_v_reuse_sessions {
        desc {
            en: """Enable TLS session reuse."""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_listener_ssl_opts_v_depth {
        desc {
            en: """Maximum number of non-self-issued intermediate certificates that can follow the peer certificate in a valid certification path. So, if depth is 0 the PEER must be signed by the trusted ROOT-CA directly; if 1 the path can be PEER, CA, ROOT-CA; if 2 the path can be PEER, CA, CA, ROOT-CA, and so on. The default value is 10."""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_listener_ssl_opts_v_password {
        desc {
            en: """String containing the user's password. Only used if the private
    key file is password-protected."""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_listener_ssl_opts_v_versions {
        desc {
            en: """All TLS/DTLS versions to be supported.<br>
    NOTE: PSK ciphers are suppressed by 'tlsv1.3' version config<br>
    In case PSK cipher suites are intended, make sure to configured
    <code>['tlsv1.2', 'tlsv1.1']</code> here."""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_listener_ssl_opts_v_ciphers {
        desc {
            en: """This config holds TLS cipher suite names separated by comma,
    or as an array of strings. e.g.
    <code>"TLS_AES_256_GCM_SHA384,TLS_AES_128_GCM_SHA256"</code> or
    <code>["TLS_AES_256_GCM_SHA384","TLS_AES_128_GCM_SHA256"]</code>.
    <br>
    Ciphers (and their ordering) define the way in which the
    client and server encrypts information over the network connection.
    Selecting a good cipher suite is critical for the
    application's data security, confidentiality and performance.

    The names should be in OpenSSL string format (not RFC format).
    All default values and examples provided by EMQX config
    documentation are all in OpenSSL format.<br>

    NOTE: Certain cipher suites are only compatible with
    specific TLS <code>versions</code> ('tlsv1.1', 'tlsv1.2' or 'tlsv1.3')
    incompatible cipher suites will be silently dropped.
    For instance, if only 'tlsv1.3' is given in the <code>versions</code>,
    configuring cipher suites for other versions will have no effect.
    <br>

    NOTE: PSK ciphers are suppressed by 'tlsv1.3' version config<br>
    If PSK cipher suites are intended, 'tlsv1.3' should be disabled from <code>versions</code>.<br>
    PSK cipher suites: <code>"RSA-PSK-AES256-GCM-SHA384,RSA-PSK-AES256-CBC-SHA384,
    RSA-PSK-AES128-GCM-SHA256,RSA-PSK-AES128-CBC-SHA256,
    RSA-PSK-AES256-CBC-SHA,RSA-PSK-AES128-CBC-SHA,
    RSA-PSK-DES-CBC3-SHA,RSA-PSK-RC4-SHA"</code><br>
    """
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_listener_ssl_opts_v_user_lookup_fun {
        desc {
            en: """EMQX-internal callback that is used to lookup pre-shared key (PSK) identity."""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_listener_ssl_opts_v_secure_renegotiate {
        desc {
            en: """SSL parameter renegotiation is a feature that allows a client and a server
    to renegotiate the parameters of the SSL connection on the fly.
    RFC 5746 defines a more secure way of doing this. By enabling secure renegotiation,
    you drop support for the insecure renegotiation, prone to MitM attacks."""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_listener_ssl_opts_v_dhfile {
        desc {
            en: """Path to a file containing PEM-encoded Diffie-Hellman parameters
    to be used by the server if a cipher suite using Diffie-Hellman
    key exchange is negotiated. If not specified, default parameters
    are used.<br>
    NOTE: The <code>dhfile</code> option is not supported by TLS 1.3."""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_listener_ssl_opts_v_fail_if_no_peer_cert {
        desc {
            en: """Used together with {verify, verify_peer} by an TLS/DTLS server.
    If set to true, the server fails if the client does not have a
    certificate to send, that is, sends an empty certificate.
    If set to false, it fails only if the client sends an invalid
    certificate (an empty certificate is considered valid)."""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_listener_ssl_opts_v_honor_cipher_order {
        desc {
            en: """An important security setting, it forces the cipher to be set based
    on the server-specified order instead of the client-specified order,
    hence enforcing the (usually more properly configured) security
    ordering of the server administrator."""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_listener_ssl_opts_v_client_renegotiation {
        desc {
            en: """In protocols that support client-initiated renegotiation,
    the cost of resources of such an operation is higher for the server than the client.
    This can act as a vector for denial of service attacks.
    The SSL application already takes measures to counter-act such attempts,
    but client-initiated renegotiation can be strictly disabled by setting this option to false.
    The default value is true. Note that disabling renegotiation can result in
    long-lived connections becoming unusable due to limits on
    the number of messages the underlying cipher suite can encipher."""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_listener_wss_opts_v_enable {
        desc {
            en: """Enable TLS."""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_listener_wss_opts_v_cacertfile {
        desc {
            en: """Trusted PEM format CA certificates bundle file.<br>
    The certificates in this file are used to verify the TLS peer's certificates.
    Append new certificates to the file if new CAs are to be trusted.
    There is no need to restart EMQX to have the updated file loaded, because
    the system regularly checks if file has been updated (and reload).<br>
    NOTE: invalidating (deleting) a certificate from the file will not affect
    already established connections.
    """
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_listener_wss_opts_v_certfile {
        desc {
            en: """PEM format certificates chain file.<br>
    The certificates in this file should be in reversed order of the certificate
    issue chain. That is, the host's certificate should be placed in the beginning
    of the file, followed by the immediate issuer certificate and so on.
    Although the root CA certificate is optional, it should be placed at the end of
    the file if it is to be added."""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_listener_wss_opts_v_keyfile {
        desc {
            en: """PEM format private key file."""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_listener_wss_opts_v_verify {
        desc {
            en: """Enable or disable peer verification."""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_listener_wss_opts_v_reuse_sessions {
        desc {
            en: """Enable TLS session reuse."""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_listener_wss_opts_v_depth {
        desc {
            en: """Maximum number of non-self-issued intermediate certificates that can follow the peer certificate in a valid certification path. So, if depth is 0 the PEER must be signed by the trusted ROOT-CA directly; if 1 the path can be PEER, CA, ROOT-CA; if 2 the path can be PEER, CA, CA, ROOT-CA, and so on. The default value is 10."""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_listener_wss_opts_v_password {
        desc {
            en: """String containing the user's password. Only used if the private
    key file is password-protected."""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_listener_wss_opts_v_versions {
        desc {
            en: """All TLS/DTLS versions to be supported.<br>
    NOTE: PSK ciphers are suppressed by 'tlsv1.3' version config<br>
    In case PSK cipher suites are intended, make sure to configured
    <code>['tlsv1.2', 'tlsv1.1']</code> here."""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_listener_wss_opts_v_ciphers {
        desc {
            en: """This config holds TLS cipher suite names separated by comma,
    or as an array of strings. e.g.
    <code>"TLS_AES_256_GCM_SHA384,TLS_AES_128_GCM_SHA256"</code> or
    <code>["TLS_AES_256_GCM_SHA384","TLS_AES_128_GCM_SHA256"]</code>.
    <br>
    Ciphers (and their ordering) define the way in which the
    client and server encrypts information over the network connection.
    Selecting a good cipher suite is critical for the
    application's data security, confidentiality and performance.

    The names should be in OpenSSL string format (not RFC format).
    All default values and examples provided by EMQX config
    documentation are all in OpenSSL format.<br>

    NOTE: Certain cipher suites are only compatible with
    specific TLS <code>versions</code> ('tlsv1.1', 'tlsv1.2' or 'tlsv1.3')
    incompatible cipher suites will be silently dropped.
    For instance, if only 'tlsv1.3' is given in the <code>versions</code>,
    configuring cipher suites for other versions will have no effect.
    <br>

    NOTE: PSK ciphers are suppressed by 'tlsv1.3' version config<br>
    If PSK cipher suites are intended, 'tlsv1.3' should be disabled from <code>versions</code>.<br>
    PSK cipher suites: <code>"RSA-PSK-AES256-GCM-SHA384,RSA-PSK-AES256-CBC-SHA384,
    RSA-PSK-AES128-GCM-SHA256,RSA-PSK-AES128-CBC-SHA256,
    RSA-PSK-AES256-CBC-SHA,RSA-PSK-AES128-CBC-SHA,
    RSA-PSK-DES-CBC3-SHA,RSA-PSK-RC4-SHA"</code><br>
    """
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_listener_wss_opts_v_user_lookup_fun {
        desc {
            en: """EMQX-internal callback that is used to lookup pre-shared key (PSK) identity."""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_listener_wss_opts_v_secure_renegotiate {
        desc {
            en: """SSL parameter renegotiation is a feature that allows a client and a server
    to renegotiate the parameters of the SSL connection on the fly.
    RFC 5746 defines a more secure way of doing this. By enabling secure renegotiation,
    you drop support for the insecure renegotiation, prone to MitM attacks."""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_listener_wss_opts_v_dhfile {
        desc {
            en: """Path to a file containing PEM-encoded Diffie-Hellman parameters
    to be used by the server if a cipher suite using Diffie-Hellman
    key exchange is negotiated. If not specified, default parameters
    are used.<br>
    NOTE: The <code>dhfile</code> option is not supported by TLS 1.3."""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_listener_wss_opts_v_fail_if_no_peer_cert {
        desc {
            en: """Used together with {verify, verify_peer} by an TLS/DTLS server.
    If set to true, the server fails if the client does not have a
    certificate to send, that is, sends an empty certificate.
    If set to false, it fails only if the client sends an invalid
    certificate (an empty certificate is considered valid)."""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_listener_wss_opts_v_honor_cipher_order {
        desc {
            en: """An important security setting, it forces the cipher to be set based
    on the server-specified order instead of the client-specified order,
    hence enforcing the (usually more properly configured) security
    ordering of the server administrator."""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_listener_wss_opts_v_client_renegotiation {
        desc {
            en: """In protocols that support client-initiated renegotiation,
    the cost of resources of such an operation is higher for the server than the client.
    This can act as a vector for denial of service attacks.
    The SSL application already takes measures to counter-act such attempts,
    but client-initiated renegotiation can be strictly disabled by setting this option to false.
    The default value is true. Note that disabling renegotiation can result in
    long-lived connections becoming unusable due to limits on
    the number of messages the underlying cipher suite can encipher."""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_listener_wss_opts_v_handshake_timeout {
        desc {
            en: """Maximum time duration allowed for the handshake to complete"""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_deflate_opts_v_level {
        desc {
            en: """Compression level."""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_deflate_opts_v_mem_level {
        desc {
            en: """Specifies the size of the compression state.<br/>
    Lower values decrease memory usage per connection."""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_deflate_opts_v_strategy {
        desc {
            en: """Specifies the compression strategy."""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_deflate_opts_v_server_context_takeover {
        desc {
            en: """Takeover means the compression state is retained
    between server messages."""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_deflate_opts_v_client_context_takeover {
        desc {
            en: """Takeover means the compression state is retained
    between client messages."""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_deflate_opts_v_server_max_window_bits {
        desc {
            en: """Specifies the size of the compression context for the server."""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_deflate_opts_v_client_max_window_bits {
        desc {
            en: """Specifies the size of the compression context for the client."""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_authorization_v_no_match {
        desc {
            en: """Default access control action if the user or client matches no ACL rules,
    or if no such user or client is found by the configurable authorization
    sources such as built_in_database, an HTTP API, or a query against PostgreSQL.
    Find more details in 'authorization.sources' config."""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_authorization_v_deny_action {
        desc {
            en: """The action when the authorization check rejects an operation."""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }

    f_authorization_v_cache {
        desc {
            en: """authorization.cache"""
            zh: """"""
        }
        label: {
            en: ""
            zh: ""
        }
    }


}
